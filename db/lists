- name: head
  package: base
  modules: [Prelude, Data.List]
  complexity: O(1)
  implementations:
    - name: report
      type: "[a] -> a"
      code: |
        head (x:_) = x
        head []    = error "Prelude.head: empty list"

- name: tail
  package: base
  modules: [Prelude, Data.List]
  complexity: O(1)
  implementations:
    - name: report
      type: "[a] -> [a]"
      code: |
        tail (_:xs) = xs
        tail []     = error "Prelude.tail: empty list"

- name: last
  package: base
  modules: [Prelude, Data.List]
  complexity: O(n)
  implementations:
    - name: report
      type: "[a] -> a"
      code: |
        last [x]    = x
        last (_:xs) = last xs
        last []     = error "Prelude.last: empty list"

- name: init
  package: base
  modules: [Prelude, Data.List]
  complexity: O(n)
  implementations:
    - name: report
      type: "[a] -> [a]"
      code: |
        init [x]    = []
        init (x:xs) = x : init xs
        init []     = error "Prelude.init: empty list"

- name: map
  package: base
  modules: [Prelude, Data.List]
  implementations:
    - name: report
      type: "(a -> b) -> [a] -> [b]"
      code: |
        map f []     = []
        map f (x:xs) = f x : map f xs

- name: (++)
  package: base
  modules: [Prelude, Data.List]
  complexity: O(n), where n is length of 1st argument
  implementations:
    - name: report
      type: "[a] -> [a] -> [a]"
      code: |
        []     ++ ys = ys
        (x:xs) ++ ys = x : (xs ++ ys)

- name: filter
  package: base
  modules: [Prelude, Data.List]
  implementations:
    - name: report
      type: "(a -> Bool) -> [a] -> [a]"
      code: |
        filter p []                 = []
        filter p (x:xs) | p x       = x : filter p xs
                        | otherwise = filter p xs

- name: "null"              # Without quotes it's an actual 'null' value.
  package: base
  modules: [Prelude, Data.List]
  complexity: O(1)
  implementations:
    - name: report
      type: "[a] -> Bool"
      code: |
        null []    = True
        null (_:_) = False

- name: length
  package: base
  modules: [Prelude, Data.List]
  complexity: O(n)
  implementations:
    - name: report
      type: "[a] -> Int"
      code: |
        length []     = 0
        length (_:xs) = 1 + length xs

- name: (!!)
  package: base
  modules: [Prelude, Data.List]
  complexity: O(index)
  implementations:
    - name: report
      type: "[a] -> Int -> a"
      code: |
        xs     !! n | n < 0 = error "Prelude.!!: negative index"
        []     !! _         = error "Prelude.!!: index too large"
        (x:_)  !! 0         = x
        (_:xs) !! n         = xs !! (n-1)

- name: reverse
  package: base
  modules: [Prelude, Data.List]
  complexity: O(n)
  implementations:
    - name: report
      type: "[a] -> [a]"
      code: |
        reverse = foldl (flip (:)) []
    - name: naive
      type: "[a] -> [a]"
      complexity: O(nÂ²)
      code: |
        reverse []     = []
        reverse (x:xs) = reverse xs ++ [x]
    - name: with accumulator
      type: "[a] -> [a]"
      code: |
        reverse s = rev s []
          where
            rev []     acc = acc
            rev (x:xs) acc = rev xs (x:acc)
